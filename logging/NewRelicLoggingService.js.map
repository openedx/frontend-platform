{"version":3,"sources":["../../src/logging/NewRelicLoggingService.js"],"names":["MAX_ERROR_LENGTH","fixErrorLength","error","message","length","processedError","Object","create","substring","pageActionNameInfo","pageActionNameIgnoredError","sendPageAction","actionName","customAttributes","process","env","NODE_ENV","console","log","window","newrelic","addPageAction","sendError","noticeError","NewRelicLoggingService","options","config","undefined","ignoredErrorRegexes","IGNORED_ERROR_REGEX","infoStringOrErrorObject","customAttrs","infoCustomAttributes","errorStringOrObject","errorCustomAttributes","allCustomAttributes","keys","errorMessage","match"],"mappings":"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","sourcesContent":["/**\n * NewRelic will not log an error if it is too long.\n *\n * @ignore\n */\nexport const MAX_ERROR_LENGTH = 4000;\n\nfunction fixErrorLength(error) {\n  if (error.message && error.message.length > MAX_ERROR_LENGTH) {\n    const processedError = Object.create(error);\n    processedError.message = processedError.message.substring(0, MAX_ERROR_LENGTH);\n    return processedError;\n  }\n  if (typeof error === 'string' && error.length > MAX_ERROR_LENGTH) {\n    return error.substring(0, MAX_ERROR_LENGTH);\n  }\n  return error;\n}\n\n/* Constants used as New Relic page action names. */\nconst pageActionNameInfo = 'INFO';\nconst pageActionNameIgnoredError = 'IGNORED_ERROR';\n\nfunction sendPageAction(actionName, message, customAttributes) {\n  if (process.env.NODE_ENV === 'development') {\n    console.log(message, customAttributes); // eslint-disable-line\n  }\n  if (window && typeof window.newrelic !== 'undefined') {\n    window.newrelic.addPageAction(actionName, { message, ...customAttributes });\n  }\n}\n\nfunction sendError(error, customAttributes) {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(error, customAttributes); // eslint-disable-line\n  }\n  if (window && typeof window.newrelic !== 'undefined') {\n    window.newrelic.noticeError(fixErrorLength(error), customAttributes);\n  }\n}\n\n/**\n * The NewRelicLoggingService is a concrete implementation of the logging service interface that\n * sends messages to NewRelic that can be seen in NewRelic Browser and NewRelic Insights. When in\n * development mode, all messages will instead be sent to the console.\n *\n * When you use `logError`, your errors will be checked to see if they're ignored *or* not.\n * Not-ignored errors will appear under \"JS errors\" for your Browser application.\n *\n * ```\n * SELECT * from JavaScriptError WHERE errorStatus is not null SINCE 10 days ago\n * ```\n *\n * Ignored errors will appear in New Relic Insights as page actions, which can be queried:\n *\n * ```\n * SELECT * from PageAction WHERE actionName = 'IGNORED_ERROR' SINCE 1 hour ago\n * ```\n *\n * When using `logInfo`, these only appear in New Relic Insights when querying for page actions as\n * follows:\n *\n * ```\n * SELECT * from PageAction WHERE actionName = 'INFO' SINCE 1 hour ago\n * ```\n *\n * You can also add your own custom metrics as an additional argument, or see the code to find\n * other standard custom attributes.\n *\n * Requires the NewRelic Browser JavaScript snippet.\n *\n * @implements {LoggingService}\n * @memberof module:Logging\n */\nexport default class NewRelicLoggingService {\n  constructor(options) {\n    const config = options ? options.config : undefined;\n    /*\n        String which is an explicit error message regex. If an error message matches the regex, the error\n        is considered an *ignored* error and submitted to New Relic as a page action - not an error.\n\n        Ignored error regexes are configured per frontend application (MFE).\n\n        The regex for all ignored errors are represented in the .env files as a single string. If you need to\n        ignore multiple errors, use the standard `|` regex syntax.\n\n        For example, here's a .env line which ignores two specific errors:\n\n        IGNORED_ERROR_REGEX='^\\\\[frontend-auth\\\\] Unimportant Error|Specific non-critical error #[\\\\d]+'\n\n        This example would ignore errors with the following messages:\n\n        [frontend-app-generic] - Specific non-critical error #45678 happened.\n        [frontend-app-generic] - Specific non-critical error #93475 happened.\n        [frontend-auth] Unimportant Error: Browser strangeness occurred.\n\n        To test your regex additions, use a JS CLI environment (such as node) and run code like this:\n\n        x = new RegExp('^\\\\[frontend-auth\\\\] Unimportant Error|Specific non-critical error #[\\\\d]+');\n        '[frontend-app-generic] - Specific non-critical error #45678 happened.'.match(x);\n        '[frontend-auth] Unimportant Error: Browser strangeness occurred.'.match(x);\n        'This error should not match anything!'.match(x);\n\n        For edx.org, add new error message regexes in edx-internal YAML as needed.\n    */\n    this.ignoredErrorRegexes = config ? config.IGNORED_ERROR_REGEX : undefined;\n  }\n\n  /**\n   *\n   *\n   * @param {*} infoStringOrErrorObject\n   * @param {*} [customAttributes={}]\n   * @memberof NewRelicLoggingService\n   */\n  logInfo(infoStringOrErrorObject, customAttributes = {}) {\n    let message = infoStringOrErrorObject;\n    let customAttrs = customAttributes;\n    if (typeof infoStringOrErrorObject === 'object' && 'message' in infoStringOrErrorObject) {\n      /* Caller has passed in an error object to be logged as a page action. */\n      /* Extract the attributes and the message. */\n      const infoCustomAttributes = infoStringOrErrorObject.customAttributes || {};\n      customAttrs = { ...infoCustomAttributes, ...customAttributes };\n      message = infoStringOrErrorObject.message;\n    }\n    sendPageAction(pageActionNameInfo, message, customAttrs);\n  }\n\n  /**\n   *\n   *\n   * @param {*} errorStringOrObject\n   * @param {*} [customAttributes={}]\n   * @memberof NewRelicLoggingService\n   */\n  logError(errorStringOrObject, customAttributes = {}) {\n    const errorCustomAttributes = errorStringOrObject.customAttributes || {};\n    let allCustomAttributes = { ...errorCustomAttributes, ...customAttributes };\n    if (Object.keys(allCustomAttributes).length === 0) {\n      // noticeError expects undefined if there are no custom attributes.\n      allCustomAttributes = undefined;\n    }\n\n    /*\n        Separate the errors into ignored errors and other errors.\n        Ignored errors are logged via adding a page action.\n        Other errors are logged via noticeError and count as \"JS Errors\" for the application.\n    */\n    const errorMessage = errorStringOrObject.message || (typeof errorStringOrObject === 'string' ? errorStringOrObject : '');\n    if (this.ignoredErrorRegexes && errorMessage.match(this.ignoredErrorRegexes)) {\n      /* ignored error */\n      sendPageAction(pageActionNameIgnoredError, errorMessage, allCustomAttributes);\n    } else {\n      /*  error! */\n      sendError(errorStringOrObject, allCustomAttributes);\n    }\n  }\n}\n"],"file":"NewRelicLoggingService.js"}